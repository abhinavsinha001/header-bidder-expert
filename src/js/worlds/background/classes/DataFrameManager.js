'use strict';

import $ from 'jquery';
import Requests from './Requests';
import TabUrl from './TabUrl';
import {systemIds, responseTypes as rt} from '../../../definitions/constants';

/**
 * Storage of data frames with header bidding requests
 */
export default class DataFrameManager {
    /**
     * Constants for events generated by this class
     */
    static get EV_HBACTIVITY_CHANGE() {
        return 'hbactivity_change';
    }

    constructor(tabUrl, requests) {
        this._tabUrl = tabUrl;
        this._requests = requests;

        // Data frames per tab
        this._frames = {};
    }

    /**
     * Start this object
     */
    run() {
        this._listenEvents();

        this._tabUrl.run();
        this._requests.run();
    }

    /**
     * Return whether there's HB activity on the page
     */
    isHBActivity(tabId) {
        let frame = this.getDataFrame(tabId);
        if (!frame) {
            return false;
        }

        // Any recording with a URL other than plain DFP call means that we have spotted an
        // HB activity
        for (let i = 0; i < frame.calls.length; i++) {
            if (frame.calls[i].sysId != systemIds.SYSID_AS_DFP) {
                return true;
            }
        }
        return false;
    }

    /**
     * Return the HB activity data frame for the tab
     */
    getDataFrame(tabId) {
        return this._frames[tabId] || null;
    }

    /**
     * Start listening for the events
     */
    _listenEvents() {
        $(this._tabUrl).on(TabUrl.EV_TAB_START, this._onTabStart.bind(this));
        $(this._tabUrl).on(TabUrl.EV_TAB_END, this._onTabEnd.bind(this));
        $(this._tabUrl).on(TabUrl.EV_DOM, this._onTabDomLoaded.bind(this));
        $(this._tabUrl).on(TabUrl.EV_COMPLETED, this._onTabCompleted.bind(this));

        $(this._requests).on(Requests.EV_CALL_START, this._onCallStart.bind(this));
        $(this._requests).on(Requests.EV_CALL_END, this._onCallEnd.bind(this));
    }

    /**
     * Start recording a new data frame in the tab
     */
    _startFrame(tabId, url, tsm) {
        this._endFrame(tabId);
        this._initFrame(tabId, url, tsm);
    }

    /**
     * End recording of the frame for the tab - just delete it
     */
    _endFrame(tabId) {
        if (!this._frames[tabId]) {
            return;
        }

        delete this._frames[tabId];

        this._notifyAboutHBActivity(tabId);
    }

    /**
     * Init a new frame structure
     */
    _initFrame(tabId, url, tsm) {
        this._frames[tabId] = {
            lastBadgeNotification: null,
            tsmStarted: tsm,
            tsmEnded: null,
            msDom: null,
            msCompleted: null,
            url: url,
            calls: []
        };
    }

    /**
     * Sets an "ms" property to the tab's data frame. An "ms" property is a property with time when a particular event
     * happened. E.g. "msDom" property stores the time when the DOM has finished loading in the tab.
     */
    _markFrameMsDone(tabId, property, tsm) {
        const frame = this._frames[tabId];
        if (!frame) {
            return;
        }

        // Log only the first event, if unexpectedly multiple of them are fired
        if (frame[property] !== null) {
            return;
        }

        frame[property] = tsm - frame.tsmStarted;
    }

    /**
     * Record the start of an HB call for the tab
     */
    _startCall(tabId, callId, tsmStart, callData)
    {
        const frame = this._frames[tabId];
        if (!frame) {
            return;
        }

        let call = this._findCall(tabId, callId);
        if (!call) {
            call = {
                msStart:    tsmStart - frame.tsmStarted,
                msEnd:      null,
                callId:     callId,
                sysId:      null,
                sysType:    null,
                url:        null,
                resType:    null,
                statusCode: null
            };

            frame.calls.push(call);
        }

        $.extend(call, callData);

        // If needed - notify that we have an HB activity here
        this._notifyAboutHBActivity(tabId);
    }

    /**
     * Record the end of an HB call for the tab
     */
    _endCall(tabId, callId, tsmEnd, callData)
    {
        // Find the starting call
        const call = this._findCall(tabId, callId);
        if (!call) {
            // This is either:
            // 1) A call from previous data frame, which was already destroyed
            //    but the call events are still coming
            // 2) A call, that was deleted because at some point of time the extension was temporarily disabled
            return;
        }
        const frame = this._frames[tabId];

        call.msEnd = tsmEnd - frame.tsmStarted;
        $.extend(call, callData);
    }

    /**
     * Delete the call from its data frame
     */
    _deleteCall(tabId, callId) {
        const index = this._findCall(tabId, callId, true);
        if (index === null) {
            return;
        }

        this._frames[tabId].calls.splice(index, 1);

        this._notifyAboutHBActivity(tabId);
    }

    /**
     * Find the call by id
     */
    _findCall(tabId, callId, isReturnIndex) {
        isReturnIndex = !!isReturnIndex;

        const frame = this._frames[tabId];
        if (!frame) {
            return null;
        }

        let result = null;
        $.each(frame.calls, (index, item) => {
            if (item.callId == callId) {
                result = isReturnIndex ? index : item;
                return false; // break
            }
        });

        return result;
    }

    /**
     * If needed, raise event to report change of HB activity in the tab
     */
    _notifyAboutHBActivity(tabId) {
        const frame = this._frames[tabId];

        // If the frame doesn't exist anymore - send the note, that there's no HB activity in the tab
        if (!frame) {
            this._fireEventHBActivity(tabId);
            return;
        }

        // Otherwise update the notification, if needed
        const isHBActivity = this.isHBActivity(tabId);
        if (frame.lastBadgeNotification !== isHBActivity) {
            this._fireEventHBActivity(tabId);
            frame.lastBadgeNotification = isHBActivity;
        }
    }

    /**
     * Fire the event with information whether there's a change to the HB activity in the tab
     */
    _fireEventHBActivity(tabId) {
        $(this).trigger(DataFrameManager.EV_HBACTIVITY_CHANGE, tabId);
    }

    /**
     * A new tab has been started
     */
    _onTabStart(ev, tabInfo) {
        this._startFrame(tabInfo.tabId, tabInfo.url, tabInfo.tsm);
    }

    /**
     * The tab has ended (e.g. it has been removed)
     */
    _onTabEnd(ev, tabInfo) {
        this._endFrame(tabInfo.tabId);
    }

    /**
     * DOM has been finished in the tab
     */
    _onTabDomLoaded(ev, tabInfo) {
        this._markFrameMsDone(tabInfo.tabId, 'msDom', tabInfo.tsm);
    }

    /**
     * The page has fully loaded in the tab
     */
    _onTabCompleted(ev, tabInfo) {
        this._markFrameMsDone(tabInfo.tabId, 'msCompleted', tabInfo.tsm);
    }

    /**
     * A header bidding call has started - add it to be tracked
     */
    _onCallStart(ev, callInfo) {
        const callData = {
            sysId:      callInfo.sysId,
            sysType:    callInfo.sysType,
            url:        callInfo.url
        };

        this._startCall(callInfo.tabId, callInfo.callId, callInfo.tsm, callData);
    }

    /**
     * A header bidding call has ended - mark it as completed
     */
    _onCallEnd(ev, callInfo) {
        callInfo = this._fixRedirectErrorBug(callInfo);

        let callData = {
            resType: callInfo.resType
        };
        if (callInfo.statusCode) {
            callData.statusCode = callInfo.statusCode;
        }

        // If the call ended with a fake event - delete it
        if (callInfo.isFake) {
            this._deleteCall(callInfo.tabId, callInfo.callId);
            return;
        }

        // Call completed
        this._endCall(callInfo.tabId, callInfo.callId, callInfo.tsm, callData);
    }

    /**
     * Fix a browser (at least Chrome) bug where redirecting a request results in error generated at the end,
     * rather than successful completing of the request with 3xx status.
     */
    _fixRedirectErrorBug(callInfo) {
        // The result must be an error
        if (callInfo.resType != rt.ERROR) {
            return callInfo;
        }

        // We should be able to find this call
        const call = this._findCall(callInfo.tabId, callInfo.callId);
        if (!call) {
            return callInfo;
        }

        // The call already should have a redirect response type
        if (call.resType != rt.REDIRECT) {
            return callInfo;
        }

        // Update call info to the right data
        callInfo = JSON.parse(JSON.stringify(callInfo)); // clone
        callInfo.statusCode = call.statusCode;
        callInfo.resType = call.resType;

        return callInfo;
    }
};
